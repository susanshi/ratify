/*
Copyright The Ratify Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
	"context"
	"embed"
	"encoding/json"
	"fmt"
	"regexp"
	"strings"
	"time"

	imagespec "github.com/opencontainers/image-spec/specs-go/v1"
	"github.com/owenrumney/go-sarif/v2/sarif"
	"github.com/ratify-project/ratify/pkg/common"
	"github.com/ratify-project/ratify/pkg/ocispecs"
	"github.com/ratify-project/ratify/pkg/referrerstore"
	_ "github.com/ratify-project/ratify/pkg/referrerstore/oras"
	"github.com/ratify-project/ratify/pkg/verifier"
	"github.com/ratify-project/ratify/pkg/verifier/plugin/skel"
	"github.com/ratify-project/ratify/plugins/verifier/vulnerabilityreport/schemavalidation"
)

//go:embed schemavalidation/schemas
var embeddedFS embed.FS

const (
	SarifArtifactType        string = "application/sarif+json"
	SarifOfflineFilePath     string = "schemavalidation/schemas/sarif-2.1.0.json"
	TrivyScannerName         string = "trivy"
	GrypeScannerName         string = "grype"
	CreatedAnnotation        string = "createdAt"
	DefaultCreatedAnnotation string = imagespec.AnnotationCreated
	SeverityRegex                   = `Severity:\s*(\w+)`
)

type PluginConfig struct {
	Name                  string   `json:"name"`
	Type                  string   `json:"type"`
	SchemaURL             string   `json:"schemaURL,omitempty"`
	CreatedAnnotationName string   `json:"createdAnnotationName,omitempty"`
	MaximumAge            string   `json:"maximumAge,omitempty"`
	DisallowedSeverities  []string `json:"disallowedSeverities,omitempty"`
	Passthrough           bool     `json:"passthrough,omitempty"`
	DenylistCVEs          []string `json:"denylistCVEs,omitempty"`
}

type PluginInputConfig struct {
	Config PluginConfig `json:"config"`
}

func main() {
	skel.PluginMain("vulnerabilityreport", "1.0.0", VerifyReference, []string{"1.0.0"})
}

func parseInput(stdin []byte) (*PluginConfig, error) {
	conf := PluginInputConfig{}

	if err := json.Unmarshal(stdin, &conf); err != nil {
		return nil, fmt.Errorf("failed to parse stdin for the input: %w", err)
	}

	return &conf.Config, nil
}

func VerifyReference(args *skel.CmdArgs, subjectReference common.Reference, referenceDescriptor ocispecs.ReferenceDescriptor, referrerStore referrerstore.ReferrerStore) (*verifier.VerifierResult, error) {
	input, err := parseInput(args.StdinData)
	if err != nil {
		return nil, err
	}
	verifierType := input.Name
	if input.Type != "" {
		verifierType = input.Type
	}

	// extract created timestamp from descriptor annotations
	if input.CreatedAnnotationName == "" {
		input.CreatedAnnotationName = DefaultCreatedAnnotation
	}
	createdTime, err := extractCreationTimestamp(input.CreatedAnnotationName, referenceDescriptor)
	if err != nil {
		return &verifier.VerifierResult{
			Name:      input.Name,
			Type:      verifierType,
			IsSuccess: false,
			Message:   fmt.Sprintf("Validation failed: error extracting create timestamp annotation:[%v]", err.Error()),
		}, nil
	}

	// check report is newer than allowed maximum age
	if input.MaximumAge != "" {
		ok, err := validateMaximumAge(input.MaximumAge, createdTime)
		if err != nil {
			return &verifier.VerifierResult{
				Name:      input.Name,
				Type:      verifierType,
				IsSuccess: false,
				Message:   fmt.Sprintf("Validation failed: error validating maximum age:[%v]", err.Error()),
				Extensions: map[string]interface{}{
					CreatedAnnotation: createdTime,
				},
			}, nil
		}
		if !ok {
			return &verifier.VerifierResult{
				Name:      input.Name,
				Type:      verifierType,
				IsSuccess: false,
				Message:   fmt.Sprintf("Validation failed: report is older than maximum age:[%s]", input.MaximumAge),
				Extensions: map[string]interface{}{
					CreatedAnnotation: createdTime,
				},
			}, nil
		}
	}

	ctx := context.Background()

	referenceManifest, err := referrerStore.GetReferenceManifest(ctx, subjectReference, referenceDescriptor)
	if err != nil {
		return &verifier.VerifierResult{
			Name:      input.Name,
			Type:      verifierType,
			IsSuccess: false,
			Message:   fmt.Sprintf("Validation failed: error fetching reference manifest for subject: %s reference descriptor: %v: [%v]", subjectReference, referenceDescriptor.Descriptor, err.Error()),
			Extensions: map[string]interface{}{
				CreatedAnnotation: createdTime,
			},
		}, nil
	}

	if len(referenceManifest.Blobs) == 0 {
		return &verifier.VerifierResult{
			Name:      input.Name,
			Type:      verifierType,
			IsSuccess: false,
			Message:   fmt.Sprintf("Validation failed: no layers found in manifest for referrer %s@%s", subjectReference.Path, referenceDescriptor.Digest.String()),
			Extensions: map[string]interface{}{
				CreatedAnnotation: createdTime,
			},
		}, nil
	}

	blobDesc := referenceManifest.Blobs[0]
	refBlob, err := referrerStore.GetBlobContent(ctx, subjectReference, blobDesc.Digest)
	if err != nil {
		return &verifier.VerifierResult{
			Name:      input.Name,
			Type:      verifierType,
			IsSuccess: false,
			Message:   fmt.Sprintf("Validation failed: error fetching blob for subject:[%s] digest:[%s]: [%v]", subjectReference, blobDesc.Digest, err.Error()),
			Extensions: map[string]interface{}{
				CreatedAnnotation: createdTime,
			},
		}, nil
	}

	// skip all validation if passthrough is enabled
	if input.Passthrough {
		return &verifier.VerifierResult{
			Name:      input.Name,
			Type:      verifierType,
			IsSuccess: true,
			Message:   "Validation skipped. passthrough enabled",
			Extensions: map[string]interface{}{
				CreatedAnnotation: createdTime,
				"passthrough":     true,
				"report":          string(refBlob),
			},
		}, nil
	}

	// validate json schema
	if err := verifyJSONSchema(referenceDescriptor.ArtifactType, refBlob, input.SchemaURL); err != nil {
		return &verifier.VerifierResult{
			Name:      input.Name,
			Type:      verifierType,
			IsSuccess: false,
			Message:   fmt.Sprintf("Validation failed: schema validation failed for digest:[%s],artifact type:[%s],parse errors:[%v]", blobDesc.Digest, referenceDescriptor.ArtifactType, err.Error()),
			Extensions: map[string]interface{}{
				CreatedAnnotation: createdTime,
			},
		}, nil
	}

	if referenceDescriptor.ArtifactType == SarifArtifactType {
		return processSarifReport(input, input.Name, verifierType, refBlob, createdTime)
	}

	return &verifier.VerifierResult{
		Name:      input.Name,
		Type:      verifierType,
		IsSuccess: true,
		Message:   "Validation succeeded",
		Extensions: map[string]interface{}{
			CreatedAnnotation: createdTime,
		},
	}, nil
}

// verifyJSONSchema validates the json schema of the report
// if schemaURL is empty, it will use the offline schema embedded in binary
// currently only support for sarif reports
func verifyJSONSchema(artifactType string, refBlob []byte, schemaURL string) error {
	if artifactType == SarifArtifactType {
		// decide online or offline schema type
		if schemaURL != "" {
			return schemavalidation.LoadAndValidateOnlineSchema(schemaURL, refBlob)
		}
		schemaFileBytes, err := embeddedFS.ReadFile(SarifOfflineFilePath)
		if err != nil {
			return fmt.Errorf("error reading offline schema file:[%s]", SarifOfflineFilePath)
		}
		return schemavalidation.LoadAndValidateOfflineSchema(schemaFileBytes, refBlob)
	}
	return fmt.Errorf("media type not configured for plugin:[%s]", artifactType)
}

// processSarifReport processes the sarif report running individual validations as configured
func processSarifReport(input *PluginConfig, verifierName string, verifierType string, blob []byte, createdTime time.Time) (*verifier.VerifierResult, error) {
	sarifReport, err := sarif.FromBytes(blob)
	if err != nil {
		return &verifier.VerifierResult{
			Name:      verifierName,
			Type:      verifierType,
			IsSuccess: false,
			Message:   fmt.Sprintf("Validation failed: error parsing sarif report:[%v]", err.Error()),
			Extensions: map[string]interface{}{
				CreatedAnnotation: createdTime,
			},
		}, nil
	}
	// verify that there is at least one run in the report
	if len(sarifReport.Runs) < 1 {
		return &verifier.VerifierResult{
			Name:      verifierName,
			Type:      verifierType,
			IsSuccess: false,
			Message:   "Validation failed: no runs found in sarif report",
			Extensions: map[string]interface{}{
				CreatedAnnotation: createdTime,
			},
		}, nil
	}
	scannerName := strings.ToLower(sarifReport.Runs[0].Tool.Driver.Name)
	if len(input.DenylistCVEs) > 0 {
		verifierReport, err := verifyDenyListCVEs(input.Name, verifierType, scannerName, sarifReport, input.DenylistCVEs, createdTime)
		if err != nil {
			return nil, err
		}
		if !verifierReport.IsSuccess {
			return verifierReport, nil
		}
	}
	if len(input.DisallowedSeverities) > 0 {
		verifierReport, err := verifyDisallowedSeverities(input.Name, verifierType, scannerName, sarifReport, input.DisallowedSeverities, createdTime)
		if err != nil {
			return nil, err
		}
		if !verifierReport.IsSuccess {
			return verifierReport, nil
		}
	}

	return &verifier.VerifierResult{
		Name:      verifierName,
		Type:      verifierType,
		IsSuccess: true,
		Message:   "Validation succeeded",
		Extensions: map[string]interface{}{
			CreatedAnnotation: createdTime,
			"scanner":         scannerName,
		},
	}, nil
}

// verifyDenyListCVEs verifies that the report does not contain any deny-listed CVEs
func verifyDenyListCVEs(verifierName string, verifierType string, scannerName string, sarifReport *sarif.Report, denylistCVEs []string, createdTime time.Time) (*verifier.VerifierResult, error) {
	denylistCVESet := make(map[string]bool)
	denylistViolations := []string{}

	// convert denylistCVEs to a set for easy lookup
	for _, cve := range denylistCVEs {
		denylistCVESet[strings.ToLower(cve)] = false
	}

	// iterate over the results and check which cves are deny-listed
	for _, result := range sarifReport.Runs[0].Results {
		if result.RuleID == nil || *result.RuleID == "" {
			return &verifier.VerifierResult{
				Name:      verifierName,
				Type:      verifierType,
				IsSuccess: false,
				Message:   fmt.Sprintf("Validation failed: rule id not found for result:[%v]", result),
				Extensions: map[string]interface{}{
					"scanner":         scannerName,
					CreatedAnnotation: createdTime,
				},
			}, nil
		}
		ruleIDLower := strings.ToLower(*result.RuleID)
		if _, ok := denylistCVESet[ruleIDLower]; ok {
			denylistCVESet[ruleIDLower] = true
		}
	}

	// iterate over the denylistCVESet and add the deny-listed cves to the list of violations
	for cve, isDenylisted := range denylistCVESet {
		if isDenylisted {
			denylistViolations = append(denylistViolations, cve)
		}
	}

	if len(denylistViolations) > 0 {
		return &verifier.VerifierResult{
			Name:      verifierName,
			Type:      verifierType,
			IsSuccess: false,
			Extensions: map[string]interface{}{
				"scanner":         scannerName,
				"denylistCVEs":    denylistCVEs,
				"cveViolations":   denylistViolations,
				CreatedAnnotation: createdTime,
			},
			Message: "Validation failed: found denied CVEs. See extensions field for details.",
		}, nil
	}

	return &verifier.VerifierResult{
		Name:      verifierName,
		Type:      verifierType,
		IsSuccess: true,
		Message:   "Validation succeeded",
		Extensions: map[string]interface{}{
			"scanner":         scannerName,
			CreatedAnnotation: createdTime,
		},
	}, nil
}

// verifyDisallowedSeverities verifies that the report does not contain any disallowed severity levels
func verifyDisallowedSeverities(verifierName string, verifierType string, scannerName string, sarifReport *sarif.Report, disallowedSeverities []string, createdTime time.Time) (*verifier.VerifierResult, error) {
	ruleMap := make(map[string]*sarif.ReportingDescriptor)
	violatingRules := make(map[string]string)
	// create a map of rule id to rule for easy lookup
	for _, rule := range sarifReport.Runs[0].Tool.Driver.Rules {
		ruleMap[rule.ID] = rule
	}
	// iterate over the results and check if the severity is disallowed
	for _, result := range sarifReport.Runs[0].Results {
		if result.RuleID == nil || *result.RuleID == "" {
			return &verifier.VerifierResult{
				Name:      verifierName,
				Type:      verifierType,
				IsSuccess: false,
				Message:   fmt.Sprintf("Validation failed: rule id not found for result:[%v]", result),
				Extensions: map[string]interface{}{
					"scanner":         scannerName,
					CreatedAnnotation: createdTime,
				},
			}, nil
		}
		rule, ok := ruleMap[*result.RuleID]
		if !ok {
			return &verifier.VerifierResult{
				Name:      verifierName,
				Type:      verifierType,
				IsSuccess: false,
				Message:   fmt.Sprintf("Validation failed: rule not found for result:[%v]", result),
				Extensions: map[string]interface{}{
					"scanner":         scannerName,
					CreatedAnnotation: createdTime,
				},
			}, nil
		}
		severity, err := extractSeverity(scannerName, *rule)
		if err != nil {
			return &verifier.VerifierResult{
				Name:      verifierName,
				Type:      verifierType,
				IsSuccess: false,
				Message:   fmt.Sprintf("Validation failed: error extracting severity:[%v]", err.Error()),
				Extensions: map[string]interface{}{
					"scanner":         scannerName,
					CreatedAnnotation: createdTime,
				},
			}, nil
		}
		// check if the severity is disallowed and add it to the map of violating CVE IDs
		for _, disallowed := range disallowedSeverities {
			if strings.EqualFold(severity, disallowed) {
				violatingRules[rule.ID] = severity
			}
		}
	}
	// if there are violating rules, return them as custom extension field
	if len(violatingRules) > 0 {
		return &verifier.VerifierResult{
			Name:      verifierName,
			Type:      verifierType,
			IsSuccess: false,
			Extensions: map[string]interface{}{
				"scanner":              scannerName,
				"disallowedSeverities": disallowedSeverities,
				"severityViolations":   violatingRules,
				CreatedAnnotation:      createdTime,
			},
			Message: "Validation failed: found disallowed severities. See extensions field for details.",
		}, nil
	}
	return &verifier.VerifierResult{
		Name:      verifierName,
		Type:      verifierType,
		IsSuccess: true,
		Message:   "Validation succeeded",
		Extensions: map[string]interface{}{
			"scanner":         scannerName,
			CreatedAnnotation: createdTime,
		},
	}, nil
}

// extractSeverity extracts the severity from the rule help text using regex
// relies on the help text being in the format "Severity: <severity>"
// currently only supports trivy and grype scanners
func extractSeverity(scannerName string, rule sarif.ReportingDescriptor) (string, error) {
	if scannerName == TrivyScannerName || scannerName == GrypeScannerName {
		if rule.Help == nil || rule.Help.Text == nil || *rule.Help.Text == "" {
			return "", fmt.Errorf("help text not found for rule:[%s]", rule.ID)
		}
		re := regexp.MustCompile(SeverityRegex)
		match := re.FindStringSubmatch(*rule.Help.Text)
		if len(match) < 2 {
			return "", fmt.Errorf("severity not found in help text:[%s]", *rule.Help.Text)
		}
		return strings.ToLower(match[1]), nil
	}
	return "", fmt.Errorf("scanner not supported:[%s]", scannerName)
}

// extractCreationTimestamp extracts the created timestamp from the descriptor annotations
// verifies that the created timestamp is a valid timestamp in RFC3339 format
func extractCreationTimestamp(createdAnnotationName string, descriptor ocispecs.ReferenceDescriptor) (time.Time, error) {
	if descriptor.Annotations == nil {
		return time.Time{}, fmt.Errorf("no annotations found for descriptor:[%v]", descriptor)
	}
	created, ok := descriptor.Annotations[createdAnnotationName]
	if !ok {
		return time.Time{}, fmt.Errorf("created annotation [%s] not found for descriptor:[%v]", createdAnnotationName, descriptor)
	}
	// check if created annotation is a valid timestamp
	createdTime, err := time.Parse(time.RFC3339, created)
	if err != nil {
		return time.Time{}, fmt.Errorf("error parsing created timestamp:[%s]", created)
	}
	return createdTime, nil
}

// validateMaximumAge validates that the report is newer than the allowed maximum age
// extracts the created timestamp from the descriptor annotations
func validateMaximumAge(maximumAge string, createdTime time.Time) (bool, error) {
	// check if maxium age is a valid duration
	duration, err := time.ParseDuration(maximumAge)
	if err != nil {
		return false, fmt.Errorf("error parsing maximum age:[%s]", maximumAge)
	}
	// check if created timestamp is older than maximum age
	if time.Since(createdTime) > duration {
		return false, nil
	}

	return true, nil
}

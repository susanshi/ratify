/*
Copyright The Ratify Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
	"fmt"
	"testing"
	"time"

	"github.com/opencontainers/go-digest"
	oci "github.com/opencontainers/image-spec/specs-go/v1"
	"github.com/owenrumney/go-sarif/v2/sarif"
	"github.com/ratify-project/ratify/pkg/common"
	"github.com/ratify-project/ratify/pkg/ocispecs"
	"github.com/ratify-project/ratify/pkg/referrerstore/mocks"
	"github.com/ratify-project/ratify/pkg/verifier/plugin/skel"
)

const sampleSarifReport string = `{
	"version": "2.1.0",
	"$schema": "https://json.schemastore.org/sarif-2.1.0-rtm.5.json",
	"runs": [
		{
		"tool": {
			"driver": {
			"name": "grype",
			"version": "0.71.0",
			"informationUri": "https://github.com/anchore/grype",
			"rules": [
				{
				"id": "CVE-2022-48174-busybox",
				"name": "ApkMatcherExactDirectMatch",
				"help": {
					"text": "Vulnerability CVE-2022-48174\nSeverity: critical\nPackage: busybox\nVersion: 1.36.1-r0\nFix Version: 1.36.1-r1\nType: apk\nLocation: /lib/apk/db/installed\nData Namespace: alpine:distro:alpine:3.18\nLink: [CVE-2022-48174](http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-48174)",
					"markdown": "**Vulnerability CVE-2022-48174**\n| Severity | Package | Version | Fix Version | Type | Location | Data Namespace | Link |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n| critical  | busybox  | 1.36.1-r0  | 1.36.1-r1  | apk  | /lib/apk/db/installed  | alpine:distro:alpine:3.18  | [CVE-2022-48174](http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-48174)  |\n"
				},
				"properties": {
					"security-severity": "9.8"
				}
				}
			]
			}
		},
		"results": [
			{
			"ruleId": "CVE-2022-48174-busybox",
			"message": {
				"text": "The path /lib/apk/db/installed reports busybox at version 1.36.1-r0  which is a vulnerable (apk) package installed in the container"
			}
			}
		]
		}
	]
}`

// TestVerifyReference tests the VerifyReference function
func TestVerifyReference(t *testing.T) {
	manifestDigest := digest.FromString("test_manifest_digest")
	blobDigest := digest.FromString("test_blob_digest")
	type args struct {
		stdinData         string
		referenceManifest ocispecs.ReferenceManifest
		blobContent       string
	}
	type want struct {
		message string
		err     error
	}
	tests := []struct {
		name string
		args args
		want want
	}{
		{
			name: "invalid stdin data",
			args: args{
				stdinData:         "invalid",
				referenceManifest: ocispecs.ReferenceManifest{},
				blobContent:       sampleSarifReport,
			},
			want: want{
				err: fmt.Errorf("failed to parse stdin for the input: %s", "invalid character 'i' looking for beginning of value"),
			},
		},
		{
			name: "invalid created timestamp",
			args: args{
				stdinData:         `{"config":{"name": "vulnerabilityreport", "maximumAge": "24h"}}`,
				referenceManifest: ocispecs.ReferenceManifest{},
				blobContent:       sampleSarifReport,
			},
			want: want{
				message: fmt.Sprintf("Validation failed: error extracting create timestamp annotation:[%s]", "no annotations found for descriptor:[{{ sha256:b2f67b016d3c646f025099b363b4f83a56a44d067a846be74e8866342c56f216 0 [] map[] [] <nil> } application/sarif+json}]"),
			},
		},
		{
			name: "invalid max age",
			args: args{
				stdinData: `{"config":{"name": "vulnerabilityreport", "maximumAge": "1d"}}`,
				referenceManifest: ocispecs.ReferenceManifest{
					Annotations: map[string]string{
						"org.opencontainers.image.created": time.Now().Add(time.Hour * -30).Format(time.RFC3339),
					},
				},
				blobContent: sampleSarifReport,
			},
			want: want{
				message: fmt.Sprintf("Validation failed: error validating maximum age:[%s]", "error parsing maximum age:[1d]"),
			},
		},
		{
			name: "expired max age",
			args: args{
				stdinData: `{"config":{"name": "vulnerabilityreport", "maximumAge": "24h"}}`,
				referenceManifest: ocispecs.ReferenceManifest{
					Annotations: map[string]string{
						"org.opencontainers.image.created": time.Now().Add(time.Hour * -30).Format(time.RFC3339),
					},
				},
				blobContent: sampleSarifReport,
			},
			want: want{
				message: fmt.Sprintf("Validation failed: report is older than maximum age:[%s]", "24h"),
			},
		},
		{
			name: "no blobs in manifest",
			args: args{
				stdinData: `{"config":{"name": "vulnerabilityreport", "maximumAge": "24h"}}`,
				referenceManifest: ocispecs.ReferenceManifest{
					Annotations: map[string]string{
						"org.opencontainers.image.created": time.Now().Format(time.RFC3339),
					},
				},
				blobContent: sampleSarifReport,
			},
			want: want{
				message: fmt.Sprintf("Validation failed: no layers found in manifest for referrer %s@%s", "test_subject_path", manifestDigest.String()),
			},
		},
		{
			name: "passthrough enabled",
			args: args{
				stdinData: `{"config":{"name": "vulnerabilityreport", "maximumAge": "24h", "passthrough": true}}`,
				referenceManifest: ocispecs.ReferenceManifest{
					Annotations: map[string]string{
						"org.opencontainers.image.created": time.Now().Format(time.RFC3339),
					},
					Blobs: []oci.Descriptor{
						{
							MediaType: SarifArtifactType,
							Digest:    blobDigest,
						},
					},
				},
				blobContent: sampleSarifReport,
			},
			want: want{
				message: "Validation skipped. passthrough enabled",
			},
		},
		{
			name: "invalid json schema",
			args: args{
				stdinData: `{"config":{"name": "vulnerabilityreport", "maximumAge": "24h"}}`,
				referenceManifest: ocispecs.ReferenceManifest{
					Annotations: map[string]string{
						"org.opencontainers.image.created": time.Now().Format(time.RFC3339),
					},
					Blobs: []oci.Descriptor{
						{
							Digest: blobDigest,
						},
					},
				},
				blobContent: "{}",
			},
			want: want{
				message: fmt.Sprintf("Validation failed: schema validation failed for digest:[%s],artifact type:[%s],parse errors:[%v]", blobDigest, SarifArtifactType, "version is required: runs is required: "),
			},
		},
		{
			name: "valid report",
			args: args{
				stdinData: `{"config":{"name": "vulnerabilityreport", "maximumAge": "24h"}}`,
				referenceManifest: ocispecs.ReferenceManifest{
					Annotations: map[string]string{
						"org.opencontainers.image.created": time.Now().Format(time.RFC3339),
					},
					Blobs: []oci.Descriptor{
						{
							MediaType: SarifArtifactType,
							Digest:    blobDigest,
						},
					},
				},
				blobContent: sampleSarifReport,
			},
			want: want{
				message: "Validation succeeded",
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			cmdArgs := skel.CmdArgs{
				Version:   "1.0.0",
				Subject:   "test_subject",
				StdinData: []byte(tt.args.stdinData),
			}
			testStore := &mocks.MemoryTestStore{
				Manifests: map[digest.Digest]ocispecs.ReferenceManifest{manifestDigest: tt.args.referenceManifest},
				Blobs:     map[digest.Digest][]byte{blobDigest: []byte(tt.args.blobContent)},
			}
			subjectRef := common.Reference{
				Path:     "test_subject_path",
				Original: "test_subject",
			}
			refDesc := ocispecs.ReferenceDescriptor{
				Descriptor: oci.Descriptor{
					Digest:      manifestDigest,
					Annotations: tt.args.referenceManifest.Annotations,
				},
				ArtifactType: SarifArtifactType,
			}
			verifierResult, err := VerifyReference(&cmdArgs, subjectRef, refDesc, testStore)
			if err != nil && err.Error() != tt.want.err.Error() {
				t.Errorf("verifyReference() error = %v, wantErr %v", err, tt.want.err)
				return
			}
			if verifierResult != nil && verifierResult.Message != tt.want.message {
				t.Errorf("verifyReference() verifier report message = %s, want %s", verifierResult.Message, tt.want.message)
				return
			}
		})
	}
}

// TestVerifyJSONSchema tests the verifyJSONSchema function
func TestVerifyJSONSchema(t *testing.T) {
	type args struct {
		mediaType      string
		refBlobContent string
		schemaURL      string
	}
	type want struct {
		err error
	}
	tests := []struct {
		name string
		args args
		want want
	}{
		{
			name: "unsupported media type",
			args: args{
				mediaType: "unsupported",
			},
			want: want{
				err: fmt.Errorf("media type not configured for plugin:[%s]", "unsupported"),
			},
		},
		{
			name: "online verification success",
			args: args{
				mediaType:      SarifArtifactType,
				refBlobContent: sampleSarifReport,
				schemaURL:      "https://json.schemastore.org/sarif-2.1.0-rtm.5.json",
			},
			want: want{
				err: nil,
			},
		},
		{
			name: "offline verification success",
			args: args{
				mediaType:      SarifArtifactType,
				refBlobContent: sampleSarifReport,
			},
			want: want{
				err: nil,
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := verifyJSONSchema(tt.args.mediaType, []byte(tt.args.refBlobContent), tt.args.schemaURL)
			if err != nil && err.Error() != tt.want.err.Error() {
				t.Errorf("verifyJSONSchema() error = %v, wantErr %v", err, tt.want.err)
				return
			}
		})
	}
}

// TestProcessSarifReport tests the processSarifReport function
func TestProcessSarifReport(t *testing.T) {
	type args struct {
		input       PluginConfig
		blobContent string
	}
	type want struct {
		message string
		err     error
	}
	tests := []struct {
		name string
		args args
		want want
	}{
		{
			name: "invalid blob",
			args: args{
				input:       PluginConfig{},
				blobContent: "invalid",
			},
			want: want{
				message: fmt.Sprintf("Validation failed: error parsing sarif report:[%s]", "invalid character 'i' looking for beginning of value"),
				err:     nil,
			},
		},
		{
			name: "no runs in sarif report",
			args: args{
				input: PluginConfig{},
				blobContent: `{
	"version": "2.1.0",
	"$schema": "https://json.schemastore.org/sarif-2.1.0-rtm.5.json",
	"runs": []
}`,
			},
			want: want{
				message: "Validation failed: no runs found in sarif report",
				err:     nil,
			},
		},
		{
			name: "deny list CVE found",
			args: args{
				input: PluginConfig{
					Name:         "test_verifier",
					DenylistCVEs: []string{"CVE-2022-48174-busybox"},
				},
				blobContent: sampleSarifReport,
			},
			want: want{
				message: "Validation failed: found denied CVEs. See extensions field for details.",
				err:     nil,
			},
		},
		{
			name: "disallowed severity CVE found",
			args: args{
				input: PluginConfig{
					Name:         "test_verifier",
					DenylistCVEs: []string{"CVE-2022-48174"},
					DisallowedSeverities: []string{
						"critical",
					},
				},
				blobContent: sampleSarifReport,
			},
			want: want{
				message: "Validation failed: found disallowed severities. See extensions field for details.",
				err:     nil,
			},
		},
		{
			name: "Validation succeeded",
			args: args{
				input: PluginConfig{
					Name:         "test_verifier",
					DenylistCVEs: []string{"CVE-2022-48174"},
					DisallowedSeverities: []string{
						"high",
					},
				},
				blobContent: sampleSarifReport,
			},
			want: want{
				message: "Validation succeeded",
				err:     nil,
			},
		},
	}
	for i, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			verifierReport, err := processSarifReport(&tests[i].args.input, "sample_verifier", "", []byte(tt.args.blobContent), time.Now())
			if err != nil && err.Error() != tt.want.err.Error() {
				t.Errorf("processSarifReport() error = %v, wantErr %v", err, tt.want.err)
				return
			}
			if verifierReport.Message != tt.want.message {
				t.Errorf("processSarifReport() verifier report message = %s, want %s", verifierReport.Message, tt.want.message)
				return
			}
		})
	}
}

// TestVerifyDenyListCVEs tests the verifyDenyListCVEs function
func TestVerifyDenyListCVEs(t *testing.T) {
	validRuleID := "CVE-2021-1234"
	type args struct {
		denyListCVEs []string
		sarifReport  sarif.Report
	}
	type want struct {
		message string
		err     error
	}
	tests := []struct {
		name string
		args args
		want want
	}{
		{
			name: "rule ID does not exist for result",
			args: args{
				denyListCVEs: []string{validRuleID},
				sarifReport: sarif.Report{
					Runs: []*sarif.Run{
						{
							Tool: sarif.Tool{
								Driver: &sarif.ToolComponent{
									Name: TrivyScannerName,
									Rules: []*sarif.ReportingDescriptor{
										{
											ID: validRuleID,
										},
									},
								},
							},
							Results: []*sarif.Result{
								{},
							},
						},
					},
				},
			},
			want: want{
				message: fmt.Sprintf("Validation failed: rule id not found for result:[%v]", &sarif.Result{}),
				err:     nil,
			},
		},
		{
			name: "deny list CVEs found",
			args: args{
				denyListCVEs: []string{validRuleID},
				sarifReport: sarif.Report{
					Runs: []*sarif.Run{
						{
							Tool: sarif.Tool{
								Driver: &sarif.ToolComponent{
									Name: TrivyScannerName,
									Rules: []*sarif.ReportingDescriptor{
										{
											ID: validRuleID,
										},
									},
								},
							},
							Results: []*sarif.Result{
								{
									RuleID: &validRuleID,
								},
							},
						},
					},
				},
			},
			want: want{
				message: "Validation failed: found denied CVEs. See extensions field for details.",
				err:     nil,
			},
		},
		{
			name: "no deny list CVEs found",
			args: args{
				denyListCVEs: []string{"CVE-2021-123456"},
				sarifReport: sarif.Report{
					Runs: []*sarif.Run{
						{
							Tool: sarif.Tool{
								Driver: &sarif.ToolComponent{
									Name: TrivyScannerName,
									Rules: []*sarif.ReportingDescriptor{
										{
											ID: validRuleID,
										},
									},
								},
							},
							Results: []*sarif.Result{
								{
									RuleID: &validRuleID,
								},
							},
						},
					},
				},
			},
			want: want{
				message: "Validation succeeded",
				err:     nil,
			},
		},
	}
	for i, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			verifierReport, err := verifyDenyListCVEs("test_verifier", "", TrivyScannerName, &tests[i].args.sarifReport, tt.args.denyListCVEs, time.Now())
			if err != nil && err.Error() != tt.want.err.Error() {
				t.Errorf("verifyDenyListCVEs() error = %v, wantErr %v", err, tt.want.err)
				return
			}
			if verifierReport.Message != tt.want.message {
				t.Errorf("verifyDenyListCVEs() verifier report message = %s, want %s", verifierReport.Message, tt.want.message)
				return
			}
		})
	}
}

// TestVerifyDisallowedSeverities tests the verifyDisallowedSeverities function
func TestVerifyDisallowedSeverities(t *testing.T) {
	validSeverityText := "Severity: HIGH"
	invalidSeverityText := "invalid severity text"
	validRuleID := "RULEID"
	invalidRuleID := "invalid_rule_id"
	type args struct {
		disallowedSeverities []string
		sarifReport          sarif.Report
	}
	type want struct {
		message string
		err     error
	}
	tests := []struct {
		name string
		args args
		want want
	}{
		{
			name: "rule ID does not exist for result",
			args: args{
				disallowedSeverities: []string{"high"},
				sarifReport: sarif.Report{
					Runs: []*sarif.Run{
						{
							Tool: sarif.Tool{
								Driver: &sarif.ToolComponent{
									Name: "scanner_name",
									Rules: []*sarif.ReportingDescriptor{
										{
											ID: validRuleID,
											Help: &sarif.MultiformatMessageString{
												Text:        &validSeverityText,
												PropertyBag: *sarif.NewPropertyBag(),
											},
										},
									},
								},
							},
							Results: []*sarif.Result{
								{},
							},
						},
					},
				},
			},
			want: want{
				message: fmt.Sprintf("Validation failed: rule id not found for result:[%v]", &sarif.Result{}),
				err:     nil,
			},
		},
		{
			name: "rule ID not found for result",
			args: args{
				disallowedSeverities: []string{"high"},
				sarifReport: sarif.Report{
					Runs: []*sarif.Run{
						{
							Tool: sarif.Tool{
								Driver: &sarif.ToolComponent{
									Name: "scanner_name",
									Rules: []*sarif.ReportingDescriptor{
										{
											ID: validRuleID,
											Help: &sarif.MultiformatMessageString{
												Text:        &validSeverityText,
												PropertyBag: *sarif.NewPropertyBag(),
											},
										},
									},
								},
							},
							Results: []*sarif.Result{
								{
									RuleID: &invalidRuleID,
								},
							},
						},
					},
				},
			},
			want: want{
				message: fmt.Sprintf("Validation failed: rule not found for result:[%v]", &sarif.Result{RuleID: &invalidRuleID}),
				err:     nil,
			},
		},
		{
			name: "invalid severity extraction",
			args: args{
				disallowedSeverities: []string{"high"},
				sarifReport: sarif.Report{
					Runs: []*sarif.Run{
						{
							Tool: sarif.Tool{
								Driver: &sarif.ToolComponent{
									Name: TrivyScannerName,
									Rules: []*sarif.ReportingDescriptor{
										{
											ID: validRuleID,
											Help: &sarif.MultiformatMessageString{
												Text:        &invalidSeverityText,
												PropertyBag: *sarif.NewPropertyBag(),
											},
										},
									},
								},
							},
							Results: []*sarif.Result{
								{
									RuleID: &validRuleID,
								},
							},
						},
					},
				},
			},
			want: want{
				message: fmt.Sprintf("Validation failed: error extracting severity:[severity not found in help text:[%s]]", invalidSeverityText),
				err:     nil,
			},
		},
		{
			name: "disallowed severities found",
			args: args{
				disallowedSeverities: []string{"high"},
				sarifReport: sarif.Report{
					Runs: []*sarif.Run{
						{
							Tool: sarif.Tool{
								Driver: &sarif.ToolComponent{
									Name: TrivyScannerName,
									Rules: []*sarif.ReportingDescriptor{
										{
											ID: validRuleID,
											Help: &sarif.MultiformatMessageString{
												Text:        &validSeverityText,
												PropertyBag: *sarif.NewPropertyBag(),
											},
										},
									},
								},
							},
							Results: []*sarif.Result{
								{
									RuleID: &validRuleID,
								},
							},
						},
					},
				},
			},
			want: want{
				message: "Validation failed: found disallowed severities. See extensions field for details.",
				err:     nil,
			},
		},
		{
			name: "Validation succeeded",
			args: args{
				disallowedSeverities: []string{"critical"},
				sarifReport: sarif.Report{
					Runs: []*sarif.Run{
						{
							Tool: sarif.Tool{
								Driver: &sarif.ToolComponent{
									Name: TrivyScannerName,
									Rules: []*sarif.ReportingDescriptor{
										{
											ID: validRuleID,
											Help: &sarif.MultiformatMessageString{
												Text:        &validSeverityText,
												PropertyBag: *sarif.NewPropertyBag(),
											},
										},
									},
								},
							},
							Results: []*sarif.Result{
								{
									RuleID: &validRuleID,
								},
							},
						},
					},
				},
			},
			want: want{
				message: "Validation succeeded",
				err:     nil,
			},
		},
	}
	for i, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			verifierReport, err := verifyDisallowedSeverities("test_verifier", "", TrivyScannerName, &tests[i].args.sarifReport, tt.args.disallowedSeverities, time.Now())
			if err != nil && err.Error() != tt.want.err.Error() {
				t.Errorf("verifyDisallowedSeverities() error = %v, wantErr %v", err, tt.want.err)
				return
			}
			if verifierReport.Message != tt.want.message {
				t.Errorf("verifyDisallowedSeverities() verifier report message = %s, want %s", verifierReport.Message, tt.want.message)
				return
			}
		})
	}
}

// TestExtractSeverity tests the extractSeverity function
func TestExtractSeverity(t *testing.T) {
	validSeverityText := "Severity: HIGH"
	invalidSeverityText := "invalid severity text"
	type args struct {
		scannerName string
		rule        sarif.ReportingDescriptor
	}
	type want struct {
		severity string
		err      error
	}
	tests := []struct {
		name string
		args args
		want want
	}{
		{
			name: "unsupported scanner",
			args: args{
				scannerName: "unsupported",
				rule:        sarif.ReportingDescriptor{},
			},
			want: want{
				severity: "",
				err:      fmt.Errorf("scanner not supported:[%s]", "unsupported"),
			},
		},
		{
			name: "no rule help text",
			args: args{
				scannerName: TrivyScannerName,
				rule: sarif.ReportingDescriptor{
					ID: "RULEID",
				},
			},
			want: want{
				severity: "",
				err:      fmt.Errorf("help text not found for rule:[%s]", "RULEID"),
			},
		},
		{
			name: "severity not found in help text",
			args: args{
				scannerName: TrivyScannerName,
				rule: sarif.ReportingDescriptor{
					ID: "RULEID",
					Help: &sarif.MultiformatMessageString{
						Text:        &invalidSeverityText,
						PropertyBag: *sarif.NewPropertyBag(),
					},
				},
			},
			want: want{
				severity: "",
				err:      fmt.Errorf("severity not found in help text:[%s]", invalidSeverityText),
			},
		},
		{
			name: "severity not found in help text",
			args: args{
				scannerName: TrivyScannerName,
				rule: sarif.ReportingDescriptor{
					ID: "RULEID",
					Help: &sarif.MultiformatMessageString{
						Text:        &validSeverityText,
						PropertyBag: *sarif.NewPropertyBag(),
					},
				},
			},
			want: want{
				severity: "high",
				err:      nil,
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			severity, err := extractSeverity(tt.args.scannerName, tt.args.rule)
			if err != nil && err.Error() != tt.want.err.Error() {
				t.Errorf("extractSeverity() error = %v, wantErr %v", err, tt.want.err)
				return
			}
			if severity != tt.want.severity {
				t.Errorf("extractSeverity() severity = %v, want %v", severity, tt.want.severity)
			}
		})
	}
}

// TestExtractCreationTimestamp tests the extractCreationTimestamp function
func TestExtractCreationTimestamp(t *testing.T) {
	timestamp, _ := time.Parse(time.RFC3339, "2021-01-01T00:00:00Z")
	type args struct {
		desc ocispecs.ReferenceDescriptor
	}
	type want struct {
		created time.Time
		err     error
	}
	tests := []struct {
		name string
		args args
		want want
	}{
		{
			name: "invalid: no annotations",
			args: args{
				desc: ocispecs.ReferenceDescriptor{
					Descriptor: oci.Descriptor{},
				},
			},
			want: want{
				err:     fmt.Errorf("no annotations found for descriptor:[%v]", ocispecs.ReferenceDescriptor{Descriptor: oci.Descriptor{}}),
				created: time.Time{},
			},
		},
		{
			name: "invalid: empty annotations",
			args: args{
				desc: ocispecs.ReferenceDescriptor{
					Descriptor: oci.Descriptor{
						Annotations: map[string]string{},
					},
				},
			},
			want: want{
				err:     fmt.Errorf("created annotation [%s] not found for descriptor:[%v]", DefaultCreatedAnnotation, ocispecs.ReferenceDescriptor{Descriptor: oci.Descriptor{Annotations: map[string]string{}}}),
				created: time.Time{},
			},
		},
		{
			name: "invalid created annotation",
			args: args{
				desc: ocispecs.ReferenceDescriptor{
					Descriptor: oci.Descriptor{
						Annotations: map[string]string{
							"org.opencontainers.image.created": "invalid",
						},
					},
				},
			},
			want: want{
				err:     fmt.Errorf("error parsing created timestamp:[%s]", "invalid"),
				created: time.Time{},
			},
		},
		{
			name: "valid created annotation",
			args: args{
				desc: ocispecs.ReferenceDescriptor{
					Descriptor: oci.Descriptor{
						Annotations: map[string]string{
							"org.opencontainers.image.created": "2021-01-01T00:00:00Z",
						},
					},
				},
			},
			want: want{
				err:     fmt.Errorf("error parsing created timestamp:[%s]", "invalid"),
				created: timestamp,
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			created, err := extractCreationTimestamp(DefaultCreatedAnnotation, tt.args.desc)
			if err != nil && err.Error() != tt.want.err.Error() {
				t.Errorf("extractCreationTimestamp() error = %v, wantErr %v", err, tt.want.err)
				return
			}
			if created != tt.want.created {
				t.Errorf("extractCreationTimestamp() created = %v, want %v", created, tt.want.created)
			}
		})
	}
}

// TestValidateMaxiumAge tests the validateMaximumAge function
func TestValidateMaxiumAge(t *testing.T) {
	timestamp, _ := time.Parse(time.RFC3339, "2021-01-01T00:00:00Z")
	timestampDelayed, _ := time.Parse(time.RFC3339, "2021-01-05T00:00:00Z")
	type args struct {
		maximumAge string
		createTime time.Time
	}
	type want struct {
		valid bool
		err   error
	}
	tests := []struct {
		name string
		args args
		want want
	}{
		{
			name: "invalid maximum age, valid created annotation",
			args: args{
				maximumAge: "1d",
				createTime: timestamp,
			},
			want: want{
				valid: false,
				err:   fmt.Errorf("error parsing maximum age:[%s]", "1d"),
			},
		},
		{
			name: "valid maximum age, valid created annotation, created is older than maximum age",
			args: args{
				maximumAge: "24h",
				createTime: timestampDelayed,
			},
			want: want{
				valid: false,
				err:   nil,
			},
		},
		{
			name: "valid maximum age, valid created annotation, created is newer than maximum age",
			args: args{
				maximumAge: "24h",
				createTime: time.Now(),
			},
			want: want{
				valid: true,
				err:   nil,
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			valid, err := validateMaximumAge(tt.args.maximumAge, tt.args.createTime)
			if err != nil && err.Error() != tt.want.err.Error() {
				t.Errorf("validateMaxiumAge() error = %v, wantErr %v", err, tt.want.err)
				return
			}
			if valid != tt.want.valid {
				t.Errorf("validateMaxiumAge() valid = %v, want %v", valid, tt.want.valid)
			}
		})
	}
}
